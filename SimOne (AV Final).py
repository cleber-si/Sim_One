# -*- coding: utf-8 -*-
"""Q1 draft.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19_gVDb4T5H6PxMpjTXuMyOav0sltJt3-

# Bibs
"""

!pip install fbm
!pip install PyAstronomy

import numpy as np
from fbm import fgn
import numpy.matlib
import numpy as np
from PyAstronomy.pyTiming.pyPeriod import Gls
from scipy.fft import fft, ifft
import pandas as pd

import matplotlib.pyplot as plt
plt.rcParams["figure.figsize"] = (16,8)
tam = 16

"""# Funções

## Gera Ruído
"""

def ffgn(flux_, sigma = 0.0006, H = 0.500001, n = 1, force = False):
  '''
   Generates *exact* paths of Fractional Gaussian Noise by using
   circulant embedding (for 1/2<H<1) and Lowen's method (for 0<H<1/2).  
  
   Input: 
     sigma <- standard deviation of the time series
     H     <- Hurst exponent
     n     <- number of independent paths
     N     <- the length of the time series
     force <- if *1*, then works with the smallest integer power of 2,
              greater than or equal to N.
  
   Output:
     f     <- a (nxN) matrix.  Each row contains an independently generated
              path of FGN.
   
   Usage:
     f = ffgn(sigma,H,n,N,force);
  
   Written jointly by Yingchun Zhou (Jasmine), zhouyc@math.bu.edu 
   and Stilian Stoev, sstoev@umich.edu, September, 2005.
  
   Example:
  
    f = ffgn(1,0.8,1,2^16,0); plot(cumsum(f)); title('FBM, H=0.8');
  '''
  
  flux = np.copy(flux_)
  N = len(flux)

  if (H>0.5) and (H<1):
    '''
      Use the "circulant ebedding" technique.  This method
      works only in the case when 1/2 < H < 1.
    '''

    if force:
      N2 = 2**(np.floor(np.log2(N)));
      if N2 < N:
        N = 2*N2
      else:
        N  = N2

    # First step: specify the covariance
    Ns = np.linspace(0, N, N+1)
    c = sigma**2/2 * ((Ns+1)**(2*H) - 2*(Ns**(2*H)) + abs(Ns-1)**(2*H))
    v = [c[0:N], c[N+1:0:-1]]
    v = np.concatenate(v, axis=None)


    # Second step: calculate Fourier transform of c
    g = (fft(v)).real
    if min(g) < 0:
      raise Exception (' Some of the g(k) are negative!')
    g = abs(g)


    # Third step: generate {z(1),...,z(2*N)}
    c1 = np.sqrt(2)*np.random.normal()
    c2 = np.sqrt(2)*np.random.normal()

    z = np.zeros(N+1)
    z[0], z[-1] = c1, c2

    a = np.random.normal(size = (n, N-1))
    b = np.random.normal(size = (n, N-1))
    z1 = [complex(a[0][i], b[0][i]) for i in range(len(a[0]))]

    z = [complex(z[i], 0) for i in range(len(z))]

    for i in range(len(z)):
      if i != 0 and i != len(z)-1:
        z[i] = z1[i-1]

    y = np.copy(z)
    z1_flip = z1[::-1]
    y_sub = [z1_flip[i].conjugate() for i in range(len(z1_flip))]
    
    y = np.concatenate([y, y_sub], axis=None)
    y = y * (np.ones(n)*np.sqrt(g))


    # Fourth step: calculate the stationary process f
    f = (fft(y)).real / np.sqrt(4*N)
    f = f[0:N]

  elif H == 0.5:
    f = np.random.normal(size = (n,N))

  elif (H<0.5) and (H>0):
    f = np.random.normal(size = (n,N))

    G1 = np.random.normal(size = (n,N-1))
    G2 = np.random.normal(size = (n,N-1))
    G1_complex = [complex(0, G1[0][i]) for i in range(len(G1[0]))]
    G2_complex = [complex(0, G2[0][i]) for i in range(len(G2[0]))]

    G = [(G1_complex[i] + G2_complex[i])/np.sqrt(2) for i in range(len(G1[0]))]

    GN = np.random.normal(size = (n,1))[0][0]
    G0 = np.zeros(n)

    H2 = 2*H

    R=(1-(np.linspace(1,N-1, N-1)/N)**H2)
    R = np.concatenate([[1], R, [0], R[::-1]])

    S = np.ones(n)*(abs(fft(R, 2*N))**0.5)

    G_flip = G[::-1]
    G_sub = [G_flip[i].conjugate() for i in range(len(G_flip))]
    X = np.concatenate([[complex(0,0)], G, GN, G_sub], axis=None)
    X *= S

    x = ifft(X,2*N)
    y = np.sqrt(N)*((x[0:N] - x[0]*np.ones(N))).real
    f = sigma*N**H*np.concatenate([[y[0]], np.diff(y)], axis=None)

  else:
    raise Exception(' The value of the Hurst parameter H must be in (0,1).')

  return flux + f

"""## Gera Spots"""

def generate_spots(flux_, spots_n = 1, Peq = 15):
	n = 4321
	flux = np.copy(flux_)
	#flux = [1]*(n)

	''' Spots '''
	gamma1 = 0.3985
	gamma2 = 0.2586

	'''
	 ap, bp and cp are the coefficients that give us the bolometric specific intesity
	 of the photoshere as a function of the limb angle adopting a quadratic
	 limb-darkening law
	'''
	ap = 1 - gamma1 - gamma2
	bp = gamma1 + 2*gamma2
	cp = -gamma2

	cs = 0.850                                              # it is a coefficient specifying the spot bolometric contrast
	cf0 = 1.115
	Q = 0.5                                                 # it is a function of the phase of the solar cycle
	As = 0.01                                               # it is the spot area of the ith active region in unit of the solar surface

	ai = 90                                                 # Inclination angle of star (ranged over 0 and 90 degrees)
	ii = ai*np.pi/180                                       # inclination angle with respect to the line of sight
	theta = 0.17*np.pi                                      # it is the position of an active region on star (e.g., 30 deg)
	
	
	AmpliP = 0.2                                            # alpha=DeltaPer/Per
	P2 = Peq*(1 - AmpliP*(np.sin(theta))**2)**(-1)
	lambda_ = 2*np.pi/5


	def spot1():
		''' Spot 1 '''
		omega = 2*np.pi/Peq     # the angular velocity of the star
		c = (ap+2*bp/3+cp/2)**(-1);
		mii = np.cos(ii)*np.cos(theta) + np.sin(ii)*np.sin(theta)*np.cos(lambda_ + omega*np.linspace(0,time[-1],len(time)))   # angle of limb

		cf = cf0*(1-mii)        # contrast intensity of faculae
		s1 = 1 + (As)*(ap+bp*mii + cp*mii**2)*c*((Q*cf - cs)*mii)

		return s1
		
	def spot2():
		''' Spot 2 '''
		omega = 2*np.pi/P2
		c = (ap+2*bp/3+cp/2)**(-1)    
		mii = np.cos(ii)*np.cos(theta) + np.sin(ii)*np.sin(theta)*np.cos(lambda_ + omega*np.linspace(0,time[-1],len(time)))   # angle of limb

		cf = cf0*(1 - mii)      # contrast intensity of faculae
		s2 = 1 + (As)*(ap + bp*mii + cp*mii**2)*c*((Q*cf-cs)*mii)

		return s2


	if spots_n == 1:
		s1 = spot1()
		s1 = np.array(s1)
		flux += s1 - np.mean(s1)

	if spots_n == 2:
		s1 = spot1()
		s2 = spot2()
		spots = (s1+s2) - np.mean(s1+s2)
		flux += spots

	return flux

"""## Gera Trânsito"""

def generate_transit_lc(flux_, R_planet_frac = 0.1, R_star_frac = 1, P_orb = 15):
  flux = np.copy(flux_)

  ''' Variables Declaration '''
  # Fundamental constants
  G = 6.6738 * 10**(-11)                                              # Gravitational constant (m^3 * kg^2 * s^(-2))
  OneSec = 1.15741 * 10**(-5)                                         # One second in days
  Gday = G/(OneSec**2)                                                # G constant in days
  au = 1.495978707 * 10**(11)                                         # Astronomical Unit (in m)

  # Solar parameters
  M_sun = 1.989 * 10**30                                              # Sun's mass in kg
  R_sun = 6.957 * 10**8                                               # Sun's radius in m

  # Input Parameters
  R_star = R_star_frac * R_sun                                                  # Stellar radius in solar units
  R_planet = R_planet_frac * R_sun                                             # Fraction of solar radius (Earth radius = 0.00915 R_sun)
  depth = (R_planet/R_star)**2                                        # Transit depth
  ai = 90                                                             # Inclination angle of star (ranged over 0 and 90 degrees)
  cadence = 0.020833     # Kepler's cadence                           # Cadence in days (Kepler mission)
  #cadence = 0.0002895    # PLATO'S CADENCE
  aa = ( P_orb**2 / ((4*(np.pi)**2)/(Gday*M_sun)) ) ** (1/3) #/ au    # Major semi-axis (in m)
  b = (aa/R_star) * np.cos(ai*np.pi/180)                              # Impact parameter (in a/R_star)


  # Total time
  part1 = R_star/aa;
  part2 = np.sqrt(((1 + np.sqrt(depth))**2) - (b**2))
  part3 = np.sqrt(((1-np.sqrt(depth))**2) - (b**2))

  tTotal=(P_orb/np.pi) * np.arcsin((part1*part2)/np.sqrt(1-np.cos(np.pi/180*ai)**2)) # in days
  tF = (P_orb/np.pi) * np.arcsin(np.sin(tTotal*np.pi/P_orb)*(part3/part2)) # in days
  tTh=tTotal*24 # in hours
  tFh=tF*24 # in hours
  


  ''' Create a planetary transit '''
  # Trapezoidal wave
  tramp = (tTotal - tF)/2   # ramp time
  ntTF = tramp/cadence
  nt = int(np.ceil(ntTF))
  ntF = np.ceil(tF/cadence)

  interTransit = np.ceil(P_orb/cadence-tramp)

  rampdown = np.linspace(1, 1-depth, nt)
  rampup = np.linspace(1-depth, 1, nt)

  #x0 = 1*np.ones(int(interTransit/2), float)
  x1 = (1-depth)*np.ones(int(ntF), float)
  x2 = 1*np.ones(int(interTransit/2), float)

  pulse = [x2, rampdown, x1, rampup, x2]
  pulse = np.concatenate(pulse, axis=None)

  rep = int(np.ceil(len(flux) / len(pulse)))

  pulse_train = np.matlib.repmat(pulse, 1, rep)
  PT = pulse_train[0]

  if len(PT) < len(flux):
    fill = len(flux) - len(PT)
    PT = np.append(PT, [1]*fill)

  if len(PT) > len(flux):
    fill = - len(flux) + len(PT)
    ref = int(len(flux) - fill)
    index = [i+ref for i in range(fill)]
    PT = np.delete(PT, index)

  #PT = ffgn(PT)

  flux = flux + PT - 1

  return flux

"""## Periodograma"""

def periodogram(time_, flux_, Peq):
	time = np.copy(time_)
	flux = np.copy(flux_)

	gls = Gls((time, flux))

	# Obtenha o índice associado à maior potência
	index = np.argmax(gls.power)

	# e maior potência e frequência associada
	pow_max = gls.power[index]
	freq_max = gls.freq[index]

	re_Peq = 1/freq_max
	re_error = abs(Peq - re_Peq) / Peq * 100

#	erro_relativo = abs(self.Peq - self.hpp) / self.Peq
  #print(f'Erro relativo: {erro_relativo}')

	print(f'Period: {re_Peq} days')
	print(f'Relative Error: {re_error}%')

	return gls.power, gls.freq, re_Peq, re_error

"""# Execussão

## Declaração das Estrelas
"""

''' Subsolar parameters (based on properties of typical M-type main-sequence stars) '''
Peq_sub = np.linspace(0.33, 17.35, 10)                                                       # Subsolar equatorial period
m_sub = [0.57, 0.5, 0.44, 0.37, 0.37, 0.23, 0.162, 0.102, 0.09, 0.085, 0.079]                # Subsolar mass fraction of Sun's mass
r_sub = [0.588, 0.501, 0.446, 0.361, 0.274, 0.196, 0.137, 0.12, 0.114, 0.102]                # Subsolar radius fraction of Sun's radius

''' Solar parameters (based on properties of typical G-type main-sequence stars) '''
Peq_solar = np.linspace(28.26, 32.7, 10)                                                     # Subsolar equatorial period
m_solar = [1.06, 1.03, 1, 0.99, 0.985, 0.98, 0.97, 0.95, 0.94, 0.9]                          # Subsolar mass fraction of Sun's mass
r_solar = [1.1, 1.06, 1.012, 1.002, 0.991, 0.977, 0.949, 0.927, 0.914, 0.853]                # Subsolar radius fraction of Sun's radius

''' Supersolar parameters (based on properties of typical B-type main-sequence stars) '''
Peq_sup = np.linspace(37.37, 67.2, 10)                                                       # Supersolar equatorial period
m_sup = [17.1, 11, 7.3, 5.4, 5.1, 4.7, 4.3, 3.92, 3.38, 2.75]                                # Supersolar mass fraction of Sun's mass
r_sup = [7.16, 5.71, 4.06, 3.61, 3.46, 3.36, 3.27, 2.94, 2.86, 2.49]                         # Supersolar radius fraction of Sun's radius

sub = []
solar = []
sup = []

for i in range(len(Peq_sub)):
  sub.append([Peq_sub[i], r_sub[i], m_sub[i]])
  solar.append([Peq_solar[i], r_solar[i], m_solar[i]])
  sup.append([Peq_sup[i], r_sup[i], m_sup[i]])

stars = [sub, solar, sup]
#stars[type (sub==0, solar==2, sup==2)][number (0-9)][atribute (Per==0, radius==1, mass==2)]

"""## Principal

### Estrela sem Planeta
"""

folder = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Only Stars/Stars'
folder_fer = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Only Stars/Frequencygrams'
folder_per = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Only Stars/Periodograms'

Q = 90                  			  # Quarter duration (in days)
cadence = 0.020833      			  # Kepler's cadence (in days)
n = int(Q/cadence)					    # Number of points based on cadence and quarter lenght
time = np.linspace(0, n, n+1)		# Creates time array with lenght equals to n+1
time *= cadence						      # Ajust the time array dimension to be in days

flux = np.array([1.0] * len(time))
fluxes = []
powers = []
frequencies = []
re_Peqs = []
re_errors = []

for type_ in range(3):
  f = []
  pwr = []
  frq = []
  reP = []
  err = []

  if type_ == 0:
    x_lim_min = 0
    x_lim_max = 20

  if type_ == 1:
    x_lim_min = 0
    x_lim_max = 40

  if type_ == 2:
    x_lim_min = 0
    x_lim_max = 70


  for star in range(len(stars[type_])):
    period_eq = stars[type_][star][0]

    flux_spot = generate_spots(flux, spots_n=2, Peq = period_eq)
    flux_spot_noise = ffgn(flux_spot, sigma = 0.002)
    
    power, freq, period, re_error = periodogram(time, flux_spot_noise, period_eq)
    print(f'Original Equatorial Period: {"%.2f" % period_eq}')

    f.append(flux_spot_noise)
    pwr.append(power)
    frq.append(freq)
    reP.append(period)
    err.append(re_error)

    types = ['Sub-Solar', 'Solar', 'Super-Solar']

    plt.plot(time, flux_spot_noise, '.k')
    plt.title(f'{types[type_]} Star Number {star}: Peq = {"%.2f" % period_eq}', fontsize=tam+2)
    plt.xlabel('Time (RBJD)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Normalized Flux', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder + f'/type-{type_} - star-{star}.pdf'
    plt.savefig(path, bbox_inches = 'tight')
    plt.show()

    plt.plot(freq, power, '.k')
    plt.title(f'{types[type_]} Star Number {star}:   re_Peq = {"%.2f" % period} | O_Peq = {"%.2f" % period_eq} | re_error = {"%.2f" % re_error}%', fontsize=tam+2)
    plt.xlabel('Frequency (1/day)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Signal Power', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder_fer + f'/type-{type_} - star-{star}.pdf'
    plt.savefig(path, bbox_inches = 'tight')
    plt.show()

    plt.plot(1/freq, power, '.k')
    plt.title(f'{types[type_]} Star Number {star}:   re_Peq = {"%.2f" % period} | O_Peq = {"%.2f" % period_eq} | re_error = {"%.2f" % re_error}%', fontsize=tam+2)
    plt.xlim(x_lim_min, x_lim_max)
    plt.xlabel('Period (day)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Signal Power', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder_per + f'/type-{type_} - star-{star}.pdf'
    plt.savefig(path, bbox_inches = 'tight')
    plt.show()
  
  fluxes.append(f)
  powers.append(pwr)
  frequencies.append(frq)
  re_Peqs.append(reP)
  re_errors.append(err)

"""### Estrela com Netuno"""

folder = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Stars With Neptune/Stars'
folder_fer = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Stars With Neptune/Frequencygrams'
folder_per = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Stars With Neptune/Periodograms'

Q = 90                  			  # Quarter duration (in days)
cadence = 0.020833      			  # Kepler's cadence (in days)
n = int(Q/cadence)					    # Number of points based on cadence and quarter lenght
time = np.linspace(0, n, n+1)		# Creates time array with lenght equals to n+1
time *= cadence						      # Ajust the time array dimension to be in days

R_sun = 6.957 * 10**8
r_planet = 24622 * 10**3/R_sun

flux = np.array([1.0] * len(time))

fluxes_nep = []
powers_nep = []
frequencies_nep = []
re_Peqs_nep = []
re_errors_nep = []

for type_ in range(3):
  f = []
  pwr = []
  frq = []
  reP = []
  err = []

  if type_ == 0:
    x_lim_min = 0
    x_lim_max = 20

  if type_ == 1:
    x_lim_min = 0
    x_lim_max = 40

  if type_ == 2:
    x_lim_min = 0
    x_lim_max = 70


  for star in range(len(stars[type_])):
    period_eq = stars[type_][star][0]

    flux_nep = generate_spots(flux, spots_n=2, Peq = period_eq)
    flux_nep = ffgn(flux_nep, sigma = 0.002)
    flux_nep = generate_transit_lc(flux_nep, R_star_frac = stars[type_][star][1], R_planet_frac=r_planet, P_orb = 15)
    
    power, freq, period, re_error = periodogram(time, flux_nep, period_eq)
    print(f'Original Equatorial Period: {"%.2f" % period_eq}')

    f.append(flux_nep)
    pwr.append(power)
    frq.append(freq)
    reP.append(period)
    err.append(re_error)

    types = ['Sub-Solar', 'Solar', 'Super-Solar']

    plt.plot(time, flux_nep, '.k')
    plt.title(f'{types[type_]} Star Number {star} whit Neptune: Peq = {"%.2f" % period_eq}', fontsize=tam+2)
    plt.xlabel('Time (RBJD)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Normalized Flux', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder + f'/type-{type_} - star-{star} Nep.pdf'
    plt.savefig(path, bbox_inches = 'tight')
    plt.show()

    plt.plot(freq, power, '.k')
    plt.title(f'{types[type_]} Star Number {star} whit Neptune:   re_Peq = {"%.2f" % period} | O_Peq = {"%.2f" % period_eq} | re_error = {"%.2f" % re_error}%', fontsize=tam+2)
    plt.xlabel('Frequency (1/day)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Signal Power', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder_fer + f'/type-{type_} - star-{star} Nep.pdf'
    plt.savefig(path, bbox_inches = 'tight')
    plt.show()

    plt.plot(1/freq, power, '.k')
    plt.title(f'{types[type_]} Star Number {star} whit Neptune:   re_Peq = {"%.2f" % period} | O_Peq = {"%.2f" % period_eq} | re_error = {"%.2f" % re_error}%', fontsize=tam+2)
    plt.xlim(x_lim_min, x_lim_max)
    plt.xlabel('Period (day)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Signal Power', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder_per + f'/type-{type_} - star-{star} Nep.pdf'
    plt.savefig(path, bbox_inches = 'tight')
    plt.show()
  
  fluxes_nep.append(f)
  powers_nep.append(pwr)
  frequencies_nep.append(frq)
  re_Peqs_nep.append(reP)
  re_errors_nep.append(err)

"""### Estrela com Jupiter"""

folder = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Stars With Jupiter/Stars'
folder_fer = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Stars With Jupiter/Frequencygrams'
folder_per = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Stars With Jupiter/Periodograms'

Q = 90                          # Quarter duration (in days)
cadence = 0.020833              # Kepler's cadence (in days)
n = int(Q/cadence)              # Number of points based on cadence and quarter lenght
time = np.linspace(0, n, n+1)   # Creates time array with lenght equals to n+1
time *= cadence                 # Ajust the time array dimension to be in days

R_sun = 6.957 * 10**8
r_planet = 69911 * 10**3/R_sun

flux = np.array([1.0] * len(time))

fluxes_jup = []
powers_jup = []
frequencies_jup = []
re_Peqs_jup = []
re_errors_jup = []

for type_ in range(3):
  f = []
  pwr = []
  frq = []
  reP = []
  err = []

  if type_ == 0:
    x_lim_min = 0
    x_lim_max = 20

  if type_ == 1:
    x_lim_min = 0
    x_lim_max = 40

  if type_ == 2:
    x_lim_min = 0
    x_lim_max = 70


  #for star in range(len(stars[type_])):
  for star in range(1):
    period_eq = stars[type_][star][0]
    star_r = stars[type_][star][1]

    flux_spot = generate_spots(flux, spots_n=2, Peq = period_eq)
    flux_spot_noise = ffgn(flux_spot, sigma = 0.002)
    flux_spot_noise_planet = generate_transit_lc(flux_spot_noise, R_star_frac = star_r, R_planet_frac = r_planet, P_orb = 15)
    
    '''
    power, freq, period, re_error = periodogram(time, flux_spot_noise, period_eq)
    print(f'Original Equatorial Period: {"%.2f" % period_eq}')

    f.append(flux)
    pwr.append(power)
    frq.append(freq)
    reP.append(period)
    err.append(re_error)
    '''

    types = ['Sub-Solar', 'Solar', 'Super-Solar']

    plt.plot(time, flux_spot_noise_planet, '.k')
    plt.title(f'{types[type_]} Star Number {star} whit Jupiter: Peq = {"%.2f" % period_eq} | Depth = {"%.2f" % (r_planet/star_r)**2}', fontsize=tam+2)
    plt.xlabel('Time (RBJD)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Normalized Flux', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder + f'/type-{type_} - star-{star} Jup.pdf'
    #plt.savefig(path, bbox_inches = 'tight')
    plt.show()

    '''
    plt.plot(freq, power, '.k')
    plt.title(f'{types[type_]} Star Number {star} whit Jupiter:   re_Peq = {"%.2f" % period} | O_Peq = {"%.2f" % period_eq} | re_error = {"%.2f" % re_error}%', fontsize=tam+2)
    plt.xlabel('Frequency (1/day)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Signal Power', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder_fer + f'/type-{type_} - star-{star} Jup.pdf'
    #plt.savefig(path, bbox_inches = 'tight')
    plt.show()

    plt.plot(1/freq, power, '.k')
    plt.title(f'{types[type_]} Star Number {star} whit Jupiter:   re_Peq = {"%.2f" % period} | O_Peq = {"%.2f" % period_eq} | re_error = {"%.2f" % re_error}%', fontsize=tam+2)
    plt.xlim(x_lim_min, x_lim_max)
    plt.xlabel('Period (day)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Signal Power', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder_per + f'/type-{type_} - star-{star} Jup.pdf'
    #plt.savefig(path, bbox_inches = 'tight')
    plt.show()
    
  
  fluxes_jup.append(f)
  powers_jup.append(pwr)
  frequencies_jup.append(frq)
  re_Peqs_jup.append(reP)
  re_errors_jup.append(err)
  '''

"""### Estrela com Super Jupiter"""

folder = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Stars With S_Jupiter/Stars'
folder_fer = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Stars With S_Jupiter/Frequencygrams'
folder_per = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/Stars With S_Jupiter/Periodograms'

Q = 90                          # Quarter duration (in days)
cadence = 0.020833              # Kepler's cadence (in days)
n = int(Q/cadence)              # Number of points based on cadence and quarter lenght
time = np.linspace(0, n, n+1)   # Creates time array with lenght equals to n+1
time *= cadence                 # Ajust the time array dimension to be in days

R_sun = 6.957 * 10**8
r_planet = 4 * 69911 * 10**3/R_sun

flux = np.array([1.0] * len(time))

fluxes_sjup = []
powers_sjup = []
frequencies_sjup = []
re_Peqs_sjup = []
re_errors_sjup = []

for type_ in range(3):
  f = []
  pwr = []
  frq = []
  reP = []
  err = []

  if type_ == 0:
    x_lim_min = 0
    x_lim_max = 20

  if type_ == 1:
    x_lim_min = 0
    x_lim_max = 40

  if type_ == 2:
    x_lim_min = 0
    x_lim_max = 70


  for star in range(len(stars[type_])):
    period_eq = stars[type_][star][0]

    flux_spot = generate_spots(flux, spots_n=2, Peq = period_eq)
    flux_spot_noise = ffgn(flux_spot, sigma = 0.002)
    flux_spot_noise_planet = generate_transit_lc(flux_spot_noise, R_star_frac = stars[type_][star][1], R_planet_frac=r_planet, P_orb = 15)
    
    power, freq, period, re_error = periodogram(time, flux_spot_noise, period_eq)
    print(f'Original Equatorial Period: {"%.2f" % period_eq}')

    f.append(flux_spot_noise_planet)
    pwr.append(power)
    frq.append(freq)
    reP.append(period)
    err.append(re_error)

    types = ['Sub-Solar', 'Solar', 'Super-Solar']

    plt.plot(time, flux_spot_noise_planet, '.k')
    plt.title(f'{types[type_]} Star Number {star} whit S_Jupiter: Peq = {"%.2f" % period_eq}', fontsize=tam+2)
    plt.xlabel('Time (RBJD)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Normalized Flux', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder + f'/type-{type_} - star-{star} SJup.pdf'
    plt.savefig(path, bbox_inches = 'tight')
    plt.show()

    plt.plot(freq, power, '.k')
    plt.title(f'{types[type_]} Star Number {star} whit S_Jupiter:   re_Peq = {"%.2f" % period} | O_Peq = {"%.2f" % period_eq} | re_error = {"%.2f" % re_error}%', fontsize=tam+2)
    plt.xlabel('Frequency (1/day)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Signal Power', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder_fer + f'/type-{type_} - star-{star} SJup.pdf'
    plt.savefig(path, bbox_inches = 'tight')
    plt.show()

    plt.plot(1/freq, power, '.k')
    plt.title(f'{types[type_]} Star Number {star} whit S_Jupiter:   re_Peq = {"%.2f" % period} | O_Peq = {"%.2f" % period_eq} | re_error = {"%.2f" % re_error}%', fontsize=tam+2)
    plt.xlim(x_lim_min, x_lim_max)
    plt.xlabel('Period (day)', fontsize = tam+5)
    plt.xticks(fontsize = tam)
    plt.ylabel('Signal Power', fontsize = tam+5)
    plt.yticks(fontsize = tam)
    path = folder_per + f'/type-{type_} - star-{star} SJup.pdf'
    plt.savefig(path, bbox_inches = 'tight')
    plt.show()
  
  fluxes_sjup.append(f)
  powers_sjup.append(pwr)
  frequencies_sjup.append(frq)
  re_Peqs_sjup.append(reP)
  re_errors_sjup.append(err)

"""## Comparação"""

fluxes_jup = np.array(fluxes_jup)

fluxes_jup.shape

types = ['Sub-Solar', 'Solar', 'Super-Solar']

type_ = 0
star = 5
a_porb = 0.2

flux_tran_jup = generate_transit_lc(fluxes[type_][star], R_star_frac = stars[type_][star][1], R_planet_frac=a_porb, P_orb = 15)

'''
plt.plot(time, fluxes[type_][star], '.k')
plt.title(f'{types[type_]} Star whit Jupiter Number {star}: Peq = {"%.2f" % period_eq} | Porb = {"%.2f" % 15}', fontsize=tam+2)
plt.xlabel('Time (RBJD)', fontsize = tam+5)
plt.xticks(fontsize = tam)
plt.ylabel('Normalized Flux', fontsize = tam+5)
plt.yticks(fontsize = tam)
plt.show()
'''


#plt.plot(time, fluxes_jup[type_][star], '.')


plt.plot(time, flux_tran_jup, '.', c='red', label = f'Test planet: {a_porb} Sun Radius')
plt.plot(time, fluxes_jup[type_][star], '.', c='magenta', label = 'Neptune')
plt.plot(time, fluxes[type_][star], '.', c='blue', label = 'No Planet')
plt.legend(fontsize = tam, markerscale = 2)
plt.title(f'{types[type_]} Star whit Jupiter Number {star}: Peq = {"%.2f" % period_eq} | Porb = {"%.2f" % 15}', fontsize=tam+2)
plt.xlabel('Time (RBJD)', fontsize = tam+5)
plt.xticks(fontsize = tam)
plt.ylabel('Normalized Flux', fontsize = tam+5)
plt.yticks(fontsize = tam)
plt.show()


'''
plt.plot(time, flux_tran_jup, '.', c='red')
plt.plot(time, fluxes[type_][star], '.', c='k')
plt.title(f'{types[type_]} Star whit Jupiter Number {star}: Peq = {"%.2f" % period_eq} | Porb = {"%.2f" % 15}', fontsize=tam+2)
plt.xlabel('Time (RBJD)', fontsize = tam+5)
plt.xticks(fontsize = tam)
plt.ylabel('Normalized Flux', fontsize = tam+5)
plt.yticks(fontsize = tam)
plt.show()
'''

"""# Análise"""

re_Peqs
re_errors
re_Peqs_nep
re_errors_nep
re_Peqs_jup
re_errors_jup
re_Peqs_sjup
re_errors_sjup

results_sub = [[re_errors[0][i], re_errors_nep[0][i], re_errors_jup[0][i], re_errors_sjup[0][i]] for i in range(len(re_errors[0]))]
results_sub = np.array(results_sub)
#np.shape(results_sub)

results_solar = [[re_errors[1][i], re_errors_nep[1][i], re_errors_jup[1][i], re_errors_sjup[1][i]] for i in range(len(re_errors[1]))]
results_solar = np.array(results_solar)
#np.shape(results_solar)

results_sup = [[re_errors[2][i], re_errors_nep[2][i], re_errors_jup[2][i], re_errors_sjup[2][i]] for i in range(len(re_errors[2]))]
results_sup = np.array(results_sup)
#np.shape(results_sub)

#stars[type (sub==0, solar==2, sup==2)][number (0-9)][atribute (Per==0, radius==1, mass==2)]
stars_sub = pd.DataFrame(stars[0], columns = ['Peq', 'Radius', 'Mass'])
stars_solar = pd.DataFrame(stars[1], columns = ['Peq', 'Radius', 'Mass'])
stars_sup = pd.DataFrame(stars[2], columns = ['Peq', 'Radius', 'Mass'])

aqr = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/stars_sub.csv'
stars_sub.to_csv(aqr)
aqr = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/stars_solar.csv'
stars_solar.to_csv(aqr)
aqr = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/stars_sup.csv'
stars_sup.to_csv(aqr)

stars_ = np.concatenate([stars[0], stars[1], stars[2]])
stars_df = pd.DataFrame(stars_, columns = ['Peq', 'Radius', 'Mass'])

aqr = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/stars_df.xlsx'
stars_df.to_excel(aqr)

df1 = pd.DataFrame(results_sub, columns = ['No Planet','Neptune','Jupiter', 'Super Jupter'])

aqr = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/results_sub.csv'
df1.to_csv(aqr)

df1

df2 = pd.DataFrame(results_solar, columns = ['No Planet','Neptune','Jupiter', 'Super Jupter'])

aqr = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/results_solar.csv'
df2.to_csv(aqr)

df2

df3 = pd.DataFrame(results_sup, columns = ['No Planet','Neptune','Jupiter', 'Super Jupter'])

aqr = '/content/drive/MyDrive/_Pesquisa/Astrofísica Observacional/results_sup.csv'
df3.to_csv(aqr)

df3

"""# Draft 1"""

Q = 90                  			  # Quarter duration (in days)
cadence = 0.020833      			  # Kepler's cadence (in days)
n = int(Q/cadence)					    # Number of points based on cadence and quarter lenght
time = np.linspace(0, n, n+1)		# Creates time array with lenght equals to n+1
time *= cadence						      # Ajust the time array dimension to be in days

flux = np.array([1.0] * len(time))

plt.plot(time, flux, '.k')
plt.show()

type_ = 1
star = 0
r_planet = 0.1

period_eq = stars[type_][star][0]

flux_test = generate_spots(flux, spots_n=2, Peq = period_eq)
flux_test = ffgn(flux_test, sigma = 0.002)
#flux_test = generate_transit_lc(flux_test, R_planet_frac=r_planet, R_star_frac = stars[type_][star][1], P_orb = 15)

plt.plot(time, flux_test, '.k')
plt.title(f'{type_} Star Number {star} whit S_Jupiter: Peq = {"%.2f" % period_eq}', fontsize=tam+2)
plt.xlabel('Time (RBJD)', fontsize = tam+5)
plt.xticks(fontsize = tam)
plt.ylabel('Normalized Flux', fontsize = tam+5)
plt.yticks(fontsize = tam)
#path = folder + f'/type-{type_} - star-{star} SJup.pdf'
#plt.savefig(path, bbox_inches = 'tight')
plt.show()

flux_spot = generate_spots(flux, spots_n=2)

plt.plot(time, flux_spot, '.k')
plt.show()

flux_spot_noise = ffgn(flux_spot, sigma = 0.002)

plt.plot(time, flux_spot_noise, '.k')
plt.show()

power, freq, period, re_error = periodogram(time, flux_spot_noise, Peq=15)

plt.plot(1/freq, power, '.k')
plt.xlabel('Frequency (1/day)', fontsize = tam+5)
plt.xticks(fontsize = tam)
plt.ylabel('Signal Power', fontsize = tam+5)
plt.yticks(fontsize = tam)
plt.xlim(0, 40)
plt.show()

type_ = 2
star = 4
period_eq = stars[type_][star][1]

power, freq, period, re_error = periodogram(time, fluxes[type_][star], period_eq)

plt.plot(1/freq, power, '.k')
plt.xlabel('Frequency (1/day)', fontsize = tam+5)
plt.xticks(fontsize = tam)
plt.ylabel('Signal Power', fontsize = tam+5)
plt.yticks(fontsize = tam)
plt.xlim(0, 40)
plt.show()

flux_spot_noise_tran = generate_transit_lc(flux_spot_noise)

#flux_final = gen_noise(flux_tran_noise, hurst = 10)

plt.plot(time, flux_spot_noise_tran, '.k')
plt.show()

"""# Draft 2"""

Q = 90                  			  # Quarter duration (in days)
cadence = 0.020833      			  # Kepler's cadence (in days)
n = int(Q/cadence)					    # Number of points based on cadence and quarter lenght
time = np.linspace(0, n, n+1)		# Creates time array with lenght equals to n+1
time *= cadence						      # Ajust the time array dimension to be in days

flux = [1] * len(time)

plt.plot(time, flux, '.k')
plt.show()

flux_tran = generate_transit_lc(flux)

plt.plot(time, flux_tran, '.k')
plt.show()

flux_tran_noise = ffgn(flux_tran)

plt.plot(time, flux_tran_noise, '.k')
plt.show()

"""# Other"""

np.index(flux[flux[0]])

flux_tran, PT = generate_transit_lc(flux, R_planet_frac=0.1, P_orb = 15)
#PT = noise(PT, hurst = 0.7)

plt.plot(time, flux_tran, '.r')
plt.plot(time, flux, '.k')
plt.show()

plt.plot(time, PT, '.')
plt.show()

np.random.seed(137)
t = np.linspace(0, 10, 100)
p = np.sin(t)
percentage = 0.1
n = np.random.normal(0, p.std(), t.size) * percentage
pn = p + n

plt.plot(t, pn, '.k')
plt.show()

percentage = 0.1
n = np.random.normal(0, flux.std(), len(time)) * percentage
pn = flux + n

plt.plot(time, pn, '.k')
plt.show()

power, freq, period, re_Peq = periodogram(time, flux, period_eq)
#print(1/period)

plt.plot(1./freq, power, '.k')
plt.xlim(0, x_lim)
plt.show()

flux_tran = generate_transit_lc(flux, R_planet_frac=0.2, P_orb = 10)

plt.plot(time, flux_tran, '.k')
plt.show()

power, freq, period, re_Peq = periodogram(time, flux_tran, period_eq)
#print(1/period)

plt.plot(1./freq, power, '.k')
plt.xlim(0, 40)
plt.show()

"""## Clay Test"""

Q = 90                  			# Quarter duration (in days)
cadence = 0.010833      			# Kepler's cadence (in days)

n = int(Q/cadence)					# Number of points based on cadence and quarter lenght

flux2 = np.array([1]*(n+1))					# Creates a 'clay' flux array

flux2 = generate_transit_lc(flux2, R_planet_frac=0.5, P_orb = 9)

plt.plot(time, flux2, '.k')
plt.show()